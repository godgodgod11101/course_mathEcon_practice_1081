---
title: "20191121 class"
author: "jacky wang"
date: "2020/9/9"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(reticulate)

# 設定要使用的python（可能因要使用不同版本的python而路徑有所改變）
use_python("C:\\Users\\User\\anaconda3\\envs\\pyClassEnv_ntpu\\python.exe", required = T)
# 在名為classEnvironment的沙盒下寫python
use_condaenv("pyClassEnv_ntpu", required = T)
```
若無法執行set up chunk，按Session－＞按Restart R

**技巧**

按小齒輪－＞按chunk output in console：讓console可編譯Python（>>> Python code）。
  在console打exit，就會回復原狀（> R code）。

在console裡打“repl_python()”，讓console可編譯Python（>>> Python code）。

shift + Tab：回彈兩格。

**連結**

https://opendata.culture.tw/ --> 文化資料開放服務網





# CH8 Numpy



# dim, size & shape

```{python}
import numpy as np
```

```{python}

x_23 = np.array(
  [
    [-1, 1, 5], 
    [0, 7, 4]
  ]
)

```

```{python}

x_23.shape    # ? by ? matrix
x_23.ndim    # How many axis? 

```

## vectors to matrix

```{python}

x0 = np.array([[2,3,5,7,9,11]])
x0
x0.shape

x0.shape = (2, 3)
x0

```

另存為新的matrix：

傳統法
```{python}

x1 = x0.copy()
x1.shape = (3, 2)
x0; x1

```

reshape method（不會改變原始值）
```{python}

del x1

x1 = x0.reshape(3, 2)
x0; x1

```



# array & flat array

array
```{python}

x1 = np.array([[ 1., 2., 3.]])    # row vector
x2 = np.array([[1.],[2.],[3.]])    # column vector
x1; x2

```

flat array（少了外層的[]）
```{python}

x0 = np.array([ 1., 0., 0.])
print(x0)
x0.shape    # (3,) means (1, 3)
x0.ndim    # only one axis

```

flat array與真array運算時會被當成一列
```{python}

x0 = np.array([ 1., 0., 0.])
x1 = np.array([[0., 1., 1.]])
x2 = np.array([[0.], [1.], [1.]])
x0; x1; x2

x1.shape
x2.shape

```

```{python}

x0 + x1
x0 + x2    # broadcasting

```

上述之 x0 + x2 等於
```{python}

a0 = np.array(
  [
    [1., 0., 0.], 
    [1., 0., 0.], 
    [1., 0., 0.]
  ]
)

a2 = np.array(
  [
    [0., 0., 0.], 
    [1., 1., 1.], 
    [1., 1., 1.]
  ]
)

a0 + a2

```



# elementwise operations

照位置一一做運算

```{python}

a = np.array(
  [
    [-1., 4., -6.],
    [1., 4., 6.]
  ]
) 

b = np.array(
  [
    [1., 2., 3.],
    [1., 2., 3.]
  ]
)  

```

```{python}

a*b
a/b

```



# broadcasting

當矩陣運算所需的conformability條件不滿足時，
Python自動更動矩陣的dimension，進而滿足conformability的條件。
  dimension：指列、行數。(d0, d1)
  conformability：指兩矩陣列、行數都相等。

```{python}



```



# vectorized function

```{python}

def addsub(a,b):
    if a > b:
      return a - b
    else:
      return a + b

```

```{python}

addsub(2, 3)
addsub([2, 4], [3, -1])    # wrong! 
# addsub(
#   np.array([2, 4]), 
#   np.array([3, -1])
# )    # wrong! 

```
此函數input只能是scalar

使函數可以input array
```{python}

vec_addsub = np.vectorize(addsub)

vec_addsub(
  np.array([2, 4]), 
  np.array([3, -1])
)

vec_addsub(
  [2, 4], 
  [3, -1]
)

```

已內建的函數（可input array）：
  https://docs.scipy.org/doc/numpy/reference/ufuncs.html#available-ufuncs



# 矩陣運算

## 矩陣相乘

```{python}

A = np.array(
  [
    [2, 4],
    [1, 3]
  ]
)

B = np.array(
  [
    [-1, 2],
    [-3, 4]
  ]
)

A*B    # wrong! 
A@B

```

## 矩陣轉置

```{python}

matrix1 = np.array(
  [
    [2, 3, -1], 
    [8, 11, 5]
  ]
)

matrix1
matrix1.T

```

## 反矩陣 & 行列式

```{python}
from numpy.linalg import inv, det
```

計算
$$\hat{\beta} = (X^TX)^{-1} X^TY $$
```{python}

y = np.array([[2,3,4,6]]).T
x = np.array(
  [
    [1,1,1,1],
    [0,-2,4,7]
  ]
).T

```

```{python}

def betaFun(x, y): 
    x1 = x.T @ x
    x2 = x.T @ y
    return inv(x1) @ x2

betaFun(x, y)

```






